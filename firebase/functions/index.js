const functions = require('firebase-functions');
const admin = require('firebase-admin');
const axios = require('axios');

admin.initializeApp();
const db = admin.firestore();
const storage = admin.storage();

// Custom Tool 1: Crop Risk Tool
function cropRiskTool(weatherScore, soilType, priceVolatility) {
  // Risk calculation logic
  const soilRiskMap = {
    'Clay': 0.7,
    'Sandy': 0.9,
    'Loamy': 0.3,
    'Silt': 0.5,
    'Peaty': 0.6,
    'Chalky': 0.8
  };
  
  const soilRisk = soilRiskMap[soilType] || 0.5;
  const weatherRisk = (100 - weatherScore) / 100;
  const priceRisk = priceVolatility / 100;
  
  // Weighted risk calculation
  const riskScore = (weatherRisk * 0.4 + soilRisk * 0.3 + priceRisk * 0.3) * 100;
  
  return Math.round(Math.min(100, Math.max(0, riskScore)));
}

// Custom Tool 2: Shelf Life Tool
function shelfLifeTool(temperature, humidity, hoursSinceHarvest) {
  // Spoilage probability calculation
  const tempFactor = Math.max(0, (temperature - 20) / 20); // Higher temp = more spoilage
  const humidityFactor = Math.max(0, (humidity - 60) / 40); // Higher humidity = more spoilage
  const timeFactor = hoursSinceHarvest / 168; // Normalize to weeks
  
  const spoilageProbability = (tempFactor * 0.4 + humidityFactor * 0.3 + timeFactor * 0.3) * 100;
  
  return {
    spoilageProbability: Math.round(Math.min(100, Math.max(0, spoilageProbability))),
    recommendedAction: spoilageProbability > 60 ? 'Immediate sale required' : 
                      spoilageProbability > 30 ? 'Store in cool place' : 
                      'Safe for storage',
    estimatedDaysRemaining: Math.max(1, Math.round(14 * (1 - spoilageProbability / 100)))
  };
}

// Custom Tool 3: Advisory Formatter Tool
function advisoryFormatterTool(rawOutputs) {
  const {
    crop,
    district,
    soilType,
    growthStage,
    temperature,
    humidity,
    weatherScore,
    cropScore,
    riskScore,
    priceData
  } = rawOutputs;
  
  // Format outputs into farmer-friendly advice
  const yieldExpectation = `${(cropScore * 0.05 + 2).toFixed(1)} tons/hectare`;
  const priceTrend = `â‚¹${priceData.price}/quintal (${priceData.trend})`;
  
  let recommendation = `Based on current analysis for ${crop} in ${district}:\n\n`;
  
  if (riskScore < 30) {
    recommendation += `âœ… Excellent conditions detected! Your ${crop} crop shows strong potential.\n`;
  } else if (riskScore < 60) {
    recommendation += `âš ï¸ Moderate risk detected. Monitor your ${crop} crop carefully.\n`;
  } else {
    recommendation += `ðŸ”´ High risk identified. Consider protective measures for your ${crop} crop.\n`;
  }
  
  recommendation += `\nðŸ“ Growth Stage: ${growthStage}\n`;
  recommendation += `ðŸŒ¡ï¸ Temperature: ${temperature}Â°C (${temperature > 30 ? 'High' : temperature < 15 ? 'Low' : 'Optimal'})\n`;
  recommendation += `ðŸ’§ Humidity: ${humidity}% (${humidity > 70 ? 'High' : humidity < 40 ? 'Low' : 'Good'})\n`;
  recommendation += `ðŸŒ¾ Soil Type: ${soilType}\n\n`;
  
  recommendation += `Recommended Actions:\n`;
  if (temperature > 30) {
    recommendation += `â€¢ Increase irrigation frequency\n`;
  }
  if (humidity < 40) {
    recommendation += `â€¢ Monitor for drought stress\n`;
  }
  if (riskScore > 50) {
    recommendation += `â€¢ Consider crop insurance\n`;
  }
  recommendation += `â€¢ Expected harvest in ${Math.floor(Math.random() * 30 + 60)} days\n`;
  
  return {
    yieldExpectation,
    priceTrend,
    riskScore,
    recommendation,
    explanation: `This advisory is generated by analyzing multiple data sources: Weather Intelligence (score: ${weatherScore}/100), Crop Prediction (score: ${cropScore}/100), and current market conditions. The ${soilType} soil type is ${soilType === 'Loamy' ? 'ideal' : soilType === 'Sandy' ? 'challenging' : 'suitable'} for ${crop} cultivation.`
  };
}

// Simulate OnDemand Agent Invocation
async function invokeOnDemandAgent(agentName, inputData) {
  // In production, this would call the actual OnDemand API
  // For demo purposes, we simulate the agent response
  
  await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));
  
  const agentResponses = {
    'Farmer Interaction Agent': {
      status: 'completed',
      output: { parsedInput: inputData, chatResponse: 'Input received and validated' }
    },
    'Crop Prediction Agent': {
      status: 'completed',
      output: { 
        cropScore: Math.floor(Math.random() * 30 + 65),
        suitability: 'High',
        predictedYield: Math.random() * 2 + 3
      }
    },
    'Weather Intelligence Agent': {
      status: 'completed',
      output: {
        weatherScore: Math.floor(Math.random() * 20 + 75),
        forecast: 'Favorable conditions expected',
        alerts: []
      }
    },
    'Field Operations & IoT Agent': {
      status: 'completed',
      output: {
        irrigationSchedule: 'Every 3-4 days',
        harvestTiming: 'Optimal in 60-90 days',
        postHarvestSteps: 'Store in cool, dry place'
      }
    },
    'Decision Orchestrator Agent': {
      status: 'completed',
      output: {
        combinedScore: Math.floor(Math.random() * 20 + 70),
        recommendation: 'Proceed with current plan'
      }
    },
    'Explanation & Compliance Agent': {
      status: 'completed',
      output: {
        reasoning: 'Decision based on multi-factor analysis',
        confidence: Math.floor(Math.random() * 15 + 80)
      }
    }
  };
  
  return agentResponses[agentName] || { status: 'error', output: {} };
}

// Main Cloud Function: Run Advisory Pipeline
exports.runAdvisoryPipeline = functions.https.onCall(async (data, context) => {
  try {
    const { crop, district, soilType, growthStage, temperature, humidity, imageUrl } = data;
    
    // Store input in Firestore
    const inputRef = await db.collection('userInputs').add({
      crop,
      district,
      soilType,
      growthStage,
      temperature,
      humidity,
      imageUrl,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Execute agents sequentially
    const agentNames = [
      'Farmer Interaction Agent',
      'Crop Prediction Agent',
      'Weather Intelligence Agent',
      'Field Operations & IoT Agent',
      'Decision Orchestrator Agent',
      'Explanation & Compliance Agent'
    ];
    
    const agentOutputs = [];
    
    for (const agentName of agentNames) {
      const result = await invokeOnDemandAgent(agentName, data);
      agentOutputs.push({ agent: agentName, ...result });
      
      // Store agent output
      await db.collection('agentOutputs').add({
        inputId: inputRef.id,
        agent: agentName,
        status: result.status,
        output: result.output,
        timestamp: admin.firestore.FieldValue.serverTimestamp()
      });
    }
    
    // Use custom tools
    const weatherScore = agentOutputs[2].output.weatherScore || 80;
    const cropScore = agentOutputs[1].output.cropScore || 75;
    const priceVolatility = Math.floor(Math.random() * 30 + 10);
    
    const riskScore = cropRiskTool(weatherScore, soilType, priceVolatility);
    
    const shelfLife = shelfLifeTool(
      parseFloat(temperature) || 25,
      parseFloat(humidity) || 60,
      0 // Assuming fresh crop
    );
    
    const advisory = advisoryFormatterTool({
      crop,
      district,
      soilType,
      growthStage,
      temperature,
      humidity,
      weatherScore,
      cropScore,
      riskScore,
      priceData: {
        price: Math.floor(Math.random() * 5000 + 15000),
        trend: Math.random() > 0.5 ? 'Rising' : 'Stable'
      }
    });
    
    // Store final advisory
    await db.collection('advisories').add({
      inputId: inputRef.id,
      advisory,
      shelfLife,
      riskScore,
      timestamp: admin.firestore.FieldValue.serverTimestamp()
    });
    
    return {
      success: true,
      inputId: inputRef.id,
      agentOutputs,
      advisory,
      shelfLife,
      riskScore,
      customToolsUsed: ['cropRiskTool', 'shelfLifeTool', 'advisoryFormatterTool']
    };
    
  } catch (error) {
    console.error('Error in advisory pipeline:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

// Cloud Function: Upload Image
exports.uploadImage = functions.https.onCall(async (data, context) => {
  try {
    const { imageData, fileName } = data;
    
    // In production, this would handle actual image upload to Firebase Storage
    // For demo, we return a mock URL
    const mockUrl = `https://storage.googleapis.com/agricopilot-images/${fileName}`;
    
    return {
      success: true,
      imageUrl: mockUrl
    };
    
  } catch (error) {
    console.error('Error uploading image:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});

// Cloud Function: Get Weather Data (Mock)
exports.getWeatherData = functions.https.onCall(async (data, context) => {
  try {
    const { district } = data;
    
    // Mock weather data
    // In production, this would call a real weather API
    const weatherData = {
      district,
      temperature: Math.floor(Math.random() * 15 + 20),
      humidity: Math.floor(Math.random() * 30 + 50),
      rainfall: Math.floor(Math.random() * 50),
      forecast: 'Partly cloudy with occasional showers',
      windSpeed: Math.floor(Math.random() * 15 + 5),
      pressure: Math.floor(Math.random() * 20 + 990)
    };
    
    return {
      success: true,
      weatherData
    };
    
  } catch (error) {
    console.error('Error fetching weather:', error);
    throw new functions.https.HttpsError('internal', error.message);
  }
});
